---
title: Query data
---

A search query, or query, is a request for information about data in AIMP indexes.

AIMP supports several search methods:

* Search for exact values: search for exact values or ranges of numbers, dates, IPs, or strings.
* Full-text search: use full text queries to query unstructured textual data and find documents that best match query terms.
* Vector search: store vectors in AIMP and use approximate nearest neighbor (ANN) to find vectors that are similar, supporting use cases like semantic search.

Matches are always ordered by similarity from most similar to least similar.
Common parameters for a query request body are as follows:

| Parameter      | Description                          | Type    | Required | Default |
| -------------- | ------------------------------------ | ------- | -------- | ------- |
| size           | Max number of documents to return    | Integer | ✓        |         |
| query          | Query object (details in later part) | Object  | ✓        |         |
| includeVectors |                                                                  | Boolean |          | false   |
| consistentRead | 일관된 읽기를 사용할지 여부를 지정합니다.                                                                           | Boolean |          | false   |

<Note>
  AIMP는 Eventual consistency를 보장합니다.

  이는 Upsert 요청에 대한 응답을 받았다고 하더라도, 문서가 **실제로 인덱싱** 되기까지는 수 분의 시간이 더 소요될 수 있음을 의미합니다.

  최신 상태에 대한 쿼리를 수행해야만 한다면, **`consistentRead`** 파라미터 사용을 고려해야 합니다.

  **consistentRead**는 성능저하를 유발합니다. 반드시 필요한 상황이 아니라면, 사용하지 않는 것을 권장합니다.

  **bulk-upsert**로 요청된 문서를 검색하기 위해선 인덱싱이 완료될때까지 기다려야합니다. `(개발 예정)`

</Note>

## Query limits

| Metric                       | Limit    |
| ---------------------------- | ---------|
| Max payload size             | 6MB      |
| Max length for a document ID | ??       |
| Max vector dimensions        | 4,096    |

AIMP는 JSON 기반의 `Query DSL`(Domain Specific Language)을 제공하여 Query를 정의합니다.

Query DSL은 크게 두 가지 유형의 절로 구분됩니다.

## **Primitive query**

단독으로 사용 되어 특정 필드에서 특정 값을 찾는 역할을 담당합니다.

`queryString`, `Knn` 등이 이에 해당합니다.

## **Compound query**

`Primitive query`의 동작방식을 변경하거나 여러 쿼리를 하나로 병합하는 역할을 담당합니다.

`Bool`, `Occur` 등이 이에 해당합니다.


Query 엔드포인트는 제공된 query를 바탕으로 특정 인덱스에서 가장 **관련성이 높은** N개의 문서를 반환합니다.

관련성은 \*\*score로 표현되며, 검색의 결과는 점수가 높은순으로 정렬되어 반환됩니다.

\*\*전문 검색에서는 `BM25 algorithm`을, Vector 검색에서는 사용자가 지정한 `Similarity`를 기준으로 점수를 산정합니다.


## Example

```python
url = f"{base_url}/{api_version}/projects/{project_id}/indexes/{index_name}/query"
headers = {"content-type" : "application/json", "x-api-key" : f"{your_api_key}"}

query = {
    "size": 10,
    "query": {
      "queryString": {
          "query": "content:AIMP"
      }
    }
}

r = requests.post(url, headers=headers, json=query)
```

## Query Result

| Field    | Description                                                                                                                                       | Type       |
| -------- | ------------------------------------------------------------------------------------------------------------------------------------------------- | ---------- |
| took     | 검색에 소요된 시간(ms)을 나타냅니다.                                                                                                              | long       |
| maxScore | 검색 결과 중 가장 높은 점수를 나타냅니다.                                                                                                         | float      |
| total    | 검색 조건과 일치하는 총 문서 수를 나타냅니다. total의 값은 size보다 작거나 같을 수 있습니다.                                                      | long       |
| docs     | 검색된 문서(score가 높은 순으로 정렬)들의 배열입니다. <br />Document는 Mappings에 정의된 Field들과 Reserved Field인 id Field가 포함된 JSON입니다. | Document[] |

```json
// Query Result Example

{
  "took": 76,
  "maxScore": 10.691499,
  "total": 1,
  "docs": [
    {
      "index": "wiki_index",
      "score": 10.691499,
      "doc": {
        "id": "33201222", // Reserved Field
        "url": "https://en.wikipedia.org/wiki/AIMP",
        "title": "AIMP is awesome",
        "text": null // Mappings에 존재하지만, 실제 Document에 존재하지 않는 Field는 null로 반환
      }
    }
  ]
}
```
## Query string query


[간단한 문법을 지닌 Query string](https://lucene.apache.org/core/10_0_0/queryparser/org/apache/lucene/queryparser/flexible/standard/StandardQueryParser.html)을 사용해 문서를 검색할 수 있습니다.

이는 쿼리 파서를 통해 분석되며, 잘못된 쿼리 문자열을 사용한다면 ERROR가 반환됩니다.

`Term`, `Phrase`, `Wildcard`, `Boolean operators,` `Range operators`, `Special character escaping` \*\*\*\*등을 지원합니다.

### Parameters

| Parameter    | Description                                                                             | Required |
| ------------ | --------------------------------------------------------------------------------------- | -------- |
| query        | 검색할 쿼리 문자열을 지정합니다.                                                        | ✓        |
| defaultField | 쿼리를 적용할 기본 필드를 지정합니다. 필드를 명시하지 않은 경우 이 필드에서 검색합니다. |          |

### Example

```json
{
  "queryString": {
    "query": "AIMP OR AI",
    "defaultField": "content" // content 필드에 AIMP OR AI 단어가 포함되는 문서를 검색
  }
}
```

### Query syntax

AIMP는 [Lucene의 Query Syntax](https://lucene.apache.org/core/10_0_0/queryparser/org/apache/lucene/queryparser/flexible/standard/StandardQueryParser.html)을 기반으로 동작합니다.

Datetime과 Object Field은 아래 예시와 같이 검색할 수 있습니다.

Datetime field query

```json
// [, ]은 inclusive range를 의미합니다.
{
    "queryString": {
        "query": "createdAt:[2024-11-05T00:00:00.000Z TO 2024-11-06T00:00:00.000Z]",
				// 2024-11-05 <= createdAt <= 2024-11-06인 문서 검색
    }
}

// {, }은 exclusive range를 의미합니다.
{
    "queryString": {
        "query": "createdAt:{2024-11-05T00:00:00.000Z TO 2024-11-06T00:00:00.000Z}",
				// 2024-11-05 < createdAt < 2024-11-06인 문서 검색
    }
}

// * 사용하여 시작 시간만 설정
{
    "queryString": {
        "query": "createdAt:{2024-11-05T00:00:00.000Z TO *}",
				// createdAt이 2024-11-05 이상인 문서 검색
    }
}

// * 사용하여 종료 시간만 설정
{
    "queryString": {
        "query": "createdAt:{* TO 2024-11-06T00:00:00.000Z}",
				// createdAt이 2024-11-06 미만인 문서 검색
    }
}

// exactly match 검색도 가능합니다.
{
    "queryString": {
        "query": "\"createdAt:2024-11-05T00:00:00.000Z\"",
				// createdAt field의 값이 정확히 2024-11-05T00:00:00.000Z인 문서 검색
				// ":" 문자열을 field 구분자와 구분해주기 위해 escaping character 사용
    }
}
```

Object field query

```json
// 반드시 mappings에 objectMapping을 설정해줘야 nested field를 검색할 수 있습니다.
{
  "metadata": {
    "type": "object",
    "objectMapping": {
      "url": {"type": "keyword"},
      "author": {"type": "keyword"},
    },
  },
}

// query
query = {
    "size": 10,
    "query": {
      "queryString": {
          "query": "metadata.author:alan" // nested field 검색을 위해 .(dot)으로 연결하여 검색 수행
      }
    }
}
```

### Escaping **character**

Url 등과 같이 특수문자가 다수 포함된 Field를 검색하기 위해 escaping character(\, backslash)를 사용할 수 있습니다.

```json
"queryString": {
    "query": "node_type:NODE AND (\"https://bookmeter.com/books/5514276\" OR \"https://growinglittlebylittle.tistory.com/6\")",
		// 백슬래시를 사용하여 특수문자가 포함된 url keyword를 검색
    "defaultField": "metadata.url"
},
```

## Vector query


Vector query는 vector field를 이용해 Semantic search를 수행합니다.

AIMP는 다양한 Vector query 중 `Knn query`만을 지원합니다.

Knn(k-nearest neighor)은 인덱싱된 dense vector에서 k개의 최근접 문서를 사용자가 설정한 similarity metric을 기반으로 검색합니다.

### Parameters

| Parameter     | Description                                    | Type    | Required | Limitation                                        |
| ------------- | ---------------------------------------------- | ------- | -------- | ------------------------------------------------- |
| field         | 벡터 검색을 수행할 필드를 지정합니다.          | String  | ✓        |                                                   |
| queryVector   | 검색에 사용할 쿼리 벡터를 지정합니다.          | Float[] | ✓        | mappings에 정의된 dimension과 동일한 크기의 array |
| k             | 반환할 최근접 이웃의 수를 지정합니다.          | Integer | ✓        | 0 < k ≤ 1000                                      |
| numCandidates | 검색할 후보 문서의 수를 지정합니다.            | Integer |          | k ≤ numCandidates ≤ 5000                          |
| filter        | 벡터 검색 결과를 필터링하는 쿼리를 지정합니다. | Query   |          |                                                   |

### Example

```json
"knn": {
  "field": "text_embedding", // your vector field
  "queryVector": [
      0.030255454,
      -0.058824085,
      -0.065448694,
      -0.03987034,
      0.060786933,
      -0.15469691,
      -0.043918714,
      0.057719983,
      0.054530356,
      0.007080819
      ... // your vector's dimension
  ],
  "k": 5,
  "numCandidates": 20
}
```

### Optimization

Filter query를 사용해 Vector query를 비용 효율적으로 수행할 수 있습니다.

<Tip>
  Recall과 numCandidates에는 트레이드오프가 존재합니다. <br /> numCandidates가
  클수록 재현율이 높아질 확률이 커지지만, 쿼리를 수행하기 위한 리소스 사용량도
  증가합니다.
</Tip>

```json
"knn": {
  "filter" : { // filter query를 사용하여 검색 속도 최적화
    "queryString": {
        "query": "node_type:NODE AND \"https://bookmeter.com/books/5514276\"",
        "defaultField": "metadata.url"
    }
	}, // filtering된 문서 내에서 Vector 검색을 수행
  "field": "text_embedding",
  "queryVector": [
      0.030255454,
      -0.058824085,
      -0.065448694,
      -0.03987034,
      0.060786933,
      -0.15469691,
      -0.043918714,
      0.057719983,
      0.054530356,
      0.007080819
      ... // your vector's dimension
  ],
  "k": 5,
  "numCandidates": 20
}
```

## Boolean query

Bool query는 여러 Primitive query(queryString, Vector)를 하나의 query로 결합하는 역할을 수행합니다.

Bool query는 OR operator와 비슷한 방식으로 동작합니다.

### Examples

```json
{
  "size": 5,
  "query": {
    "bool": [
      // OR Operator를 통해 아래 두 쿼리를 결합
      {
        "queryString": {
          "query": "node_type:NODE" // node_type이 NODE인 문서 검색
        }
      },
      {
        "queryString": {
          "query": "created_at:\"2024-08-30T18:29:28.197Z\"" // created_at이 2024-08-30T18:29:28.197Z인 문서 검색
          // 특수문자를 처리하기 위해 Escaping character 사용
        }
      }
    ]
  }
}
// result : node_type이 NODE이거나 created_at이 2024-08-30T18:29:28.197Z인 문서 검색
```

Bool은 기본적으로 OR Operator와 같이 동작하지만, 다른 방식의 Operator를 사용해야 할 수도 있습니다.

Occur는 query가 어떤 식으로 발생해야하는지, 어떻게 점수에 기여해야하는지 정의하는 역할을 담당합니다.

앞선 Bool의 Example query는 should로 동작하는 예시입니다. (default = should)

### Occurrence

| Occur    | Description                                                                             |
| -------- | --------------------------------------------------------------------------------------- |
| filter   | 쿼리가 반드시 일치해야 하지만, 점수 계산에는 영향을 주지 않습니다.                      |
| must     | 쿼리가 반드시 일치해야 합니다. 검색 결과에 포함되며 점수 계산에 기여합니다.             |
| must_not | 쿼리가 일치하지 않아야 합니다. 검색 결과에서 제외되며 점수 계산에 영향을 주지 않습니다. |
| should   | 쿼리가 일치하면 좋지만 필수는 아닙니다. 일치하면 점수 계산에 기여합니다.                |

### Example occur

```json
{
  "size": 5,
  "query": {
    "bool": [
      {
        "queryString": {
	        "query": "node_type:NODE"
		    },
		    "boost" : 0.8, // ~~SCORE1 = node_type이 NODE인 문서의 score * 0.8~~
		    "occur" : "filter" // filter occurence이기 때문에 최종 점수에 영향을 주지 않음, 단 반드시 node_type은 Node여야 함
      },
	    {
        "queryString": {
	        "query": "created_at:\"2024-08-30T18:29:28.197Z\""
		    },
		    "boost" : 0.2 // SCORE2 = created_at이 2024-08-30T18:29:28.197Z인 문서의 score * 0.2
		    "occur" : "should" // should occurence이기 때문에 최종 점수에 영향을 줌
      }
    ]
  }
}
// result : 반드시 node_type은 NODE이며, 동시에 SCORE2의 값이 큰 Top 5개의 문서를 반환
```

## Boost query

Boost는 Bool로 결합된 Query에 속해 있는 특정 Primitive query의 Score에 가중치를 부여하는 역할을 담당합니다.

Boost 값은 0보다 커야 합니다.

### Examples

```json
{
  "size": 5,
  "query": {
    "bool": [
      {
        "queryString": {
          "query": "node_type:NODE"
        },
        "boost": 0.8 // SCORE1 = node_type이 NODE인 문서의 score * 0.8
      },
      {
        "queryString": {
          "query": "created_at:\"2024-08-30T18:29:28.197Z\""
        },
        "boost": 0.2 // SCORE2 = created_at이 2024-08-30T18:29:28.197Z인 문서의 score * 0.2
      }
    ]
  }
}
// result : 최종 SCORE(SCORE1 + SCORE2)의 값이 큰 Top 5개의 문서를 반환
```

## Hybrid query

예를 들어, 사용자는 특정 Url에서 파생된 다수의 콘텐츠 조각들에서 사용자의 특정 질문과 가장 유사한 콘텐츠 조각을 찾고 싶습니다.

더불어 가장 중요하게 여겨지는 특정 Term이 사용된 문서에 점수를 가산하여 최종 검색 결과에 반영하고 싶습니다.

이 경우, Term-base Query string + Vector query(with. Filter query)가 결합된 형태의 이른바, Hybrid query를 수행할 수 있습니다.

### Examples

```json
{
    size: 10,
    "query": {
        "bool": [
            {
                "queryString": {
                    "query": "content:AIMP",
                },
                "occur": "should", // 일치하는 문서는 점수에 반영
                "boost": 0.7 // score * 0.7
            },
            {
                "knn": {
                    "filter" : { // Filter query에 해당하는 문서로 1차 필터링
                            "queryString": {
                                "query": "\"https://wrtn.io\"",
                                "defaultField": "metadata.url"
                            }
                        },
                    "field": "text_embedding",
                    "queryVector": [ ... {float array} ... ],
                    "k": 5, // top5 문서에게만 점수를 부여
                    "numCandidates": 20 // 높은 재현율을 위해 numCandidates를 k보다 크게 설정
                },
                "occur": "should", // 일치한다면 점수 부여
                "boost": 0.3 // score * 0.3
            }
        ]
    }
}
```

위 예제를 설명하자면 다음과 같습니다.

총 두 개의 쿼리를 Bool query로 묶어 Query string과 Vector query가 결합된 Hybrid query를 수행합니다.

1. queryString에 들어간 `AIMP` 에 매칭되는 문서의 점수에는 0.7가 boost되어 계산됩니다.
2. knn에서는 Filter query로 1차 문서 필터링이 진행되며 이후, Vector query가 진행되며 가장 유사한 top5의 점수에 0.3이 boost되어 계산됩니다.
3. 합산된 점수가 가장 높은 10개의 문서가 반환됩니다.

<Warning>

  최종 반환 문서에는 Knn query의 top5 문서가 포함되지 않을 수 있습니다.

  queryString에서만 반환된 문서들의 점수가 Knn에서 반환된 top5 문서들의 점수 보다 클 수 있기 때문입니다.

  만일, Knn의 문서가 반드시 포함되면서 점수에도 영향을 미치길 바란다면, Knn의 occur를 must로 수정해야 합니다.

</Warning>



## Query limits

- query request, response payload limit = 6MB
- max docs in response = 1000
- max boolean clauses limit = 1024
- 0 < numCandidates ≤ 5000
- 0 < topK ≤ numCandidates
- vector dimension limit = 4096